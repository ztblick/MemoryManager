
Current goal:
- Fine-tune the performance of my state machine!

NEXT SUB-GOALS:

// TODO -- add all global variables to structs -- this allows you to pad them to cache align, categorize, etc.
// HOW? Actually declare (and initialize) the structs only once, in initializer.c. Do not use "extern."
// In the header file, declare the struct with "extern".
// Anywhere that the struct is used, include the header file. This will tell the compiler that the struct is
// external of the file, and it will find it where it is actually declared.

// "decl__spec" used to cache align things within a struct to avoid cache contention!

What is expensive?
- Locking PTEs.
    - Create slimmer, faster locks (DONE)
    - Delay lock acquisition, release locks earlier (DONE)
    - Attend to deadlock issues and bugs (TO DO)

- Trimming.
    - Initiate event only when needed.
    - Batch trim.

- Waiting for standby pages.
    - Can we have more of those ready pre-emptively?

- Finding disk slots
    - It takes us too long to find a batch of open disk slots.
    - Use bitmaps for 8x speedup.
    - Consider keeping a list of previously available slots. When batching, might as well get a few
        extras and add them to the list.
    - Clearly the disk is too full. Can we keep more pages on the active list and fewer on the modified list?

Other Future Ideas/Features:
- Only unmap pages when PTE goes from transition to disk
- Batch reads from standby to array of free lists
- Batch unmap with MapUserScatter
- Efficient list removal algorithms :)
- Review data structures to reduce cache contention

~~~~ LOCK ORDERS ~~~~

A - PTE lock
B - PFN lock
C - list head lock
D - disk slot lock

~~~ OLD THOUGHTS THAT ARE SEEMINGLY IRRELEVANT ~~~

PAGE = 4k chunk of virtual memory
FRAME = 4k chunk of physical memory

- Implement PTE and PFN data structures:
    - Create PFN and PTE structs (DONE)
    - Create Page Table - 1-to-1 maps from 4k of VA space to each PTE (DONE)
    - Create page file (malloc to hold data written out to "disk") (DONE)

Bootup:
    - Create PFN_Array - mem reserve with virtual alloc (DONE)
    - call mem commit to allocate space for each physical page (DONE)
    - add all pages to free list (DONE)
    - initialize other list heads (DONE)
    - initialize page table (malloc) (DONE)
    - initialize page file (malloc) (DONE)


 First attempt:
 - No aging
 - Trim from active list from list head
 - unmap PTE
 - Write out to disk
 - update PTE
 - modify PFN
 - then serve page up to faulting VA


 What to do when we get a page fault?
 1. Grab the PTE for that VA (done)
 2. If the PTE is in disk format, then we know we need to load its contents from the disk. (NOT DONE)
 3. If the PTE is in transition, then (not yet possible, do not think about this yet)
 4. If the PTE is zeroed, then there is nothing to be done. (done)

 5. Get a page of memory by...
 6. First trying to get a page from the free list. If you can, great! Return the first PFN on the free list. (done)
 7. If the free list is empty, trim the first page from the active list: (done)

 - Unmap the old PTE to this page -- put it into disk format
 - Write the page out to the disk, saving its disk index
 - Add the disk index to the old PTE
 - Update the PFN's PTE to the new PTE

 K. Set the PTE into its memory format. Set the valid bit to 1 and save the frame_number. (done)
 L. Set the PFN to its active state and add it to the active list. (done)
 M. Call MapUserPhysicalPages() to make the connection. (done)

 Z. Read/write to the VA - no page fault this time!

