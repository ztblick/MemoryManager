
Current goal:
- 1 GB / sec throughput with 0 latency

- Realistic simulation of a memory manager:
    - Aging (NOT STARTED)
    - Consumption-based batching (DONE)
    - Speculative reads (NOT STARTED)


Current observations:
- We over-prune. Tremendously. We only want to prune when there are still free pages (so we don't get in the way
    of operations on the standby list). And we don't want to prune too soon. When we over-prune, we end up with wayyyyy
    too many free pages, which leads to too few active pages (and unnecessary faults).

- There never seem to be enough standby or modified pages to allow for soft-faulting. This indicates that we are
    over-trimming and over-writing. That said, we have zero latency, so this doesn't seem to be a big problem
    now. But if we were actually writing to and from a disk, the times would be much slower, which increases
    the importance of soft faults. So, later on, when we add an actual disk, we will want to fine-tune the
    trimmer/writer threads to run with less aggression.

- New bug: One of the free list arrays has negative size -- -39487, in this case! This implies that we were
            able to continuously remove pages from a list we were not supposed to remove from.

- New bug: for some reason, we have an active, accessed PTE that has a locked page associated with it.
           This stops the trimmer in its tracks. Why would a page associated with an active PTE be locked?
           It must have still been locked when added to a free list, which means it was not properly unlocked
           when moved off the standby list. Culprit: user thread (possible) or pruner (more likely).

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
NEXT SUB-GOALS:

- Scrap pruner: instead, have user threads signal each other ("I am about to grab some standby pages, guys!").
                How many? Not too many. A reasonable batch (16-64 pages, I imagine). Add them to an empty free list.
                The next guy should do the same, but he should wait until the previous guy is done.

- Fix batch removals to tolerate single-page removals (TODAY!)

- Add a global field used to indicate if certain threads are ALREADY running
    - this could prevent user threads from setting the write event multiple times...

- Add a field to the thread structs indicating which locks it already holds
    - When holding a lock, periodically check to see if someone is waiting on it.

- Find a more efficient way to set accessed bits

- Evaluate the quality of the program (on with different ratios of physical to virtual)
  with aging and scheduling toggled on and off.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SUBSEQUENT GOALS:

- Modify directory structure to be more modular and easier to navigate

- Update READ_ME to reflect recent changes:
    free page caches, batch removals, user access simulation, consumption-based signaling, pruning thread

- PTE region locks, not individual PTE locks.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
THEN, any of the below:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- Cache-optimize structs to reduce contention.

- Add read/write accesses. Check readwrite bit in trimmer -- move read-only directly to standby.

- For page file: actually read from/write to a file instead of a global variable.

- De-fragment the bitmaps from time to time.

- Sort the frame number array, then commit ONCE for each group of PFNs that share a page.
    - This will drastically reduce the number of calls to VirtualAlloc with the commit flag,
      which would really speed things up during the startup phase.

- More generally: use virtual alloc (mem commit) in ANY place we are using malloc.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// "__declspec" used to cache align things within a struct to avoid cache contention!
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~ LOCK ORDERS ~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A - PTE locks
B - PFN locks
C - list locks
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~ OLD THOUGHTS THAT ARE SEEMINGLY IRRELEVANT ~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

PAGE = 4k chunk of virtual memory
FRAME = 4k chunk of physical memory

- Implement PTE and PFN data structures:
    - Create PFN and PTE structs (DONE)
    - Create Page Table - 1-to-1 maps from 4k of VA space to each PTE (DONE)
    - Create page file (malloc to hold data written out to "disk") (DONE)

Bootup:
    - Create PFN_Array - mem reserve with virtual alloc (DONE)
    - call mem commit to allocate space for each physical page (DONE)
    - add all pages to free list (DONE)
    - initialize other list heads (DONE)
    - initialize page table (malloc) (DONE)
    - initialize page file (malloc) (DONE)


 First attempt:
 - No aging
 - Trim from active list from list head
 - unmap PTE
 - Write out to disk
 - update PTE
 - modify PFN
 - then serve page up to faulting VA


 What to do when we get a page fault?
 1. Grab the PTE for that VA (done)
 2. If the PTE is in disk format, then we know we need to load its contents from the disk. (NOT DONE)
 3. If the PTE is in transition, then (not yet possible, do not think about this yet)
 4. If the PTE is zeroed, then there is nothing to be done. (done)

 5. Get a page of memory by...
 6. First trying to get a page from the free list. If you can, great! Return the first PFN on the free list. (done)
 7. If the free list is empty, trim the first page from the active list: (done)

 - Unmap the old PTE to this page -- put it into disk format
 - Write the page out to the disk, saving its disk index
 - Add the disk index to the old PTE
 - Update the PFN's PTE to the new PTE

 K. Set the PTE into its memory format. Set the valid bit to 1 and save the frame_number. (done)
 L. Set the PFN to its active state and add it to the active list. (done)
 M. Call MapUserPhysicalPages() to make the connection. (done)

 Z. Read/write to the VA - no page fault this time!

